// Code generated by sqlc. DO NOT EDIT.
// source: schema.sql

package dbsql

import (
	"context"
	"database/sql"
	"log"
	"time"
)

const addIssue = `-- name: AddIssue :one
INSERT INTO "public".issues
	(template,templateurl,templateid,templatepath,templatename,author,labels,description,reference,severity,templatemetadata,cvss,cwe,cveid,cvssmetrics,remediation,matchername,extractorname,resulttype,host,path,matchedat,extractedresults,request,response,metadata,ip,interaction,curlcommand,matcherstatus,title,createdat,updatedat,scansource,issuestate,hash,scanid) 
VALUES 
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, NOW(), NOW(), $32, $33, $34, $35) RETURNING id
`

type AddIssueParams struct {
	Template         string
	Templateurl      sql.NullString
	Templateid       sql.NullString
	Templatepath     sql.NullString
	Templatename     string
	Author           sql.NullString
	Labels           []string
	Description      string
	Reference        []string
	Severity         string
	Templatemetadata sql.NullString
	Cvss             sql.NullFloat64
	Cwe              []int32
	Cveid            sql.NullString
	Cvssmetrics      sql.NullString
	Remediation      sql.NullString
	Matchername      sql.NullString
	Extractorname    sql.NullString
	Resulttype       string
	Host             string
	Path             sql.NullString
	Matchedat        string
	Extractedresults []string
	Request          sql.NullString
	Response         sql.NullString
	Metadata         sql.NullString
	Ip               sql.NullString
	Interaction      sql.NullString
	Curlcommand      sql.NullString
	Matcherstatus    sql.NullBool
	Title            string
	Scansource       string
	Issuestate       string
	Hash             string
	Scanid           int64
}

func (q *Queries) AddIssue(ctx context.Context, arg AddIssueParams) (int64, error) {
	row := q.db.QueryRow(ctx, addIssue,
		arg.Template,
		arg.Templateurl,
		arg.Templateid,
		arg.Templatepath,
		arg.Templatename,
		arg.Author,
		arg.Labels,
		arg.Description,
		arg.Reference,
		arg.Severity,
		arg.Templatemetadata,
		arg.Cvss,
		arg.Cwe,
		arg.Cveid,
		arg.Cvssmetrics,
		arg.Remediation,
		arg.Matchername,
		arg.Extractorname,
		arg.Resulttype,
		arg.Host,
		arg.Path,
		arg.Matchedat,
		arg.Extractedresults,
		arg.Request,
		arg.Response,
		arg.Metadata,
		arg.Ip,
		arg.Interaction,
		arg.Curlcommand,
		arg.Matcherstatus,
		arg.Title,
		arg.Scansource,
		arg.Issuestate,
		arg.Hash,
		arg.Scanid,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addScan = `-- name: AddScan :one
INSERT INTO "public".scans
	( name, status, scantime, hosts, scansource, templates, targets, config, runnow, reporting, scheduleoccurence, scheduletime) VALUES ( $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ) RETURNING id
`

type AddScanParams struct {
	Name              string
	Status            string
	Scantime          int64
	Hosts             int64
	Scansource        string
	Templates         []string
	Targets           []string
	Config            sql.NullString
	Runnow            sql.NullBool
	Reporting         sql.NullString
	Scheduleoccurence sql.NullString
	Scheduletime      sql.NullString
}

func (q *Queries) AddScan(ctx context.Context, arg AddScanParams) (int64, error) {
	row := q.db.QueryRow(ctx, addScan,
		arg.Name,
		arg.Status,
		arg.Scantime,
		arg.Hosts,
		arg.Scansource,
		arg.Templates,
		arg.Targets,
		arg.Config,
		arg.Runnow,
		arg.Reporting,
		arg.Scheduleoccurence,
		arg.Scheduletime,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addTarget = `-- name: AddTarget :one
INSERT INTO public.targets
	( name, createdat, updatedat, internalid, filename, total) VALUES ($1, NOW(), NOW(), $2, $3, $4) RETURNING id
`

type AddTargetParams struct {
	Name       string
	Internalid string
	Filename   string
	Total      int64
}

func (q *Queries) AddTarget(ctx context.Context, arg AddTargetParams) (int64, error) {
	row := q.db.QueryRow(ctx, addTarget,
		arg.Name,
		arg.Internalid,
		arg.Filename,
		arg.Total,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addTemplate = `-- name: AddTemplate :one
INSERT INTO public.templates
( name, folder, "path", contents, createdat, updatedat, hash) VALUES ($1, $2, $3 , $4, NOW(), NOW(), $5) RETURNING id
`

type AddTemplateParams struct {
	Name     string
	Folder   string
	Path     string
	Contents string
	Hash     string
}

func (q *Queries) AddTemplate(ctx context.Context, arg AddTemplateParams) (int64, error) {
	row := q.db.QueryRow(ctx, addTemplate,
		arg.Name,
		arg.Folder,
		arg.Path,
		arg.Contents,
		arg.Hash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM "public".issues WHERE id=$1
`

func (q *Queries) DeleteIssue(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteIssue, id)
	return err
}

const deleteIssueByScanID = `-- name: DeleteIssueByScanID :exec
DELETE FROM "public".issues WHERE scanid=$1
`

func (q *Queries) DeleteIssueByScanID(ctx context.Context, scanid int64) error {
	_, err := q.db.Exec(ctx, deleteIssueByScanID, scanid)
	return err
}

const deleteScan = `-- name: DeleteScan :exec
DELETE FROM "public".scans WHERE id=$1
`

func (q *Queries) DeleteScan(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteScan, id)
	return err
}

const deleteTarget = `-- name: DeleteTarget :exec
DELETE FROM public.targets WHERE ID=$1
`

func (q *Queries) DeleteTarget(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTarget, id)
	return err
}

const deleteTemplate = `-- name: DeleteTemplate :exec
DELETE FROM public.templates WHERE ID=$1
`

func (q *Queries) DeleteTemplate(ctx context.Context, ids []int) error {
	log.Println("delete ids: ", ids)
	for i := range ids {
		_, err := q.db.Exec(ctx, deleteTemplate, ids[i])
		log.Println("delete id: ", ids[i])
		if err != nil {
			return err
		}
	}

	return nil
}

const getIssue = `-- name: GetIssue :one
SELECT template, templateurl, templateid, templatepath, templatename, author, labels, description, reference, severity, templatemetadata, cvss, cwe, cveid, cvssmetrics, remediation, matchername, extractorname, resulttype, host, path, matchedat, extractedresults, request, response, metadata, ip, interaction, curlcommand, matcherstatus, title, createdat, updatedat, scansource, issuestate, hash, id, scanid
FROM
	"public".issues WHERE id=$1 LIMIT 1
`

func (q *Queries) GetIssue(ctx context.Context, id int64) (Issue, error) {
	row := q.db.QueryRow(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.Template,
		&i.Templateurl,
		&i.Templateid,
		&i.Templatepath,
		&i.Templatename,
		&i.Author,
		&i.Labels,
		&i.Description,
		&i.Reference,
		&i.Severity,
		&i.Templatemetadata,
		&i.Cvss,
		&i.Cwe,
		&i.Cveid,
		&i.Cvssmetrics,
		&i.Remediation,
		&i.Matchername,
		&i.Extractorname,
		&i.Resulttype,
		&i.Host,
		&i.Path,
		&i.Matchedat,
		&i.Extractedresults,
		&i.Request,
		&i.Response,
		&i.Metadata,
		&i.Ip,
		&i.Interaction,
		&i.Curlcommand,
		&i.Matcherstatus,
		&i.Title,
		&i.Createdat,
		&i.Updatedat,
		&i.Scansource,
		&i.Issuestate,
		&i.Hash,
		&i.ID,
		&i.Scanid,
	)
	return i, err
}

const getIssues = `-- name: GetIssues :many
SELECT id, scanid, matchedat, title, severity, createdat, updatedat, scansource
FROM
	"public".issues
ORDER BY id
LIMIT $2 offset $1
`

type GetIssuesParams struct {
	SqlOffset int32
	SqlLimit  int32
}

type GetIssuesRow struct {
	ID         int64
	Scanid     int64
	Matchedat  string
	Title      string
	Severity   string
	Createdat  time.Time
	Updatedat  time.Time
	Scansource string
}

func (q *Queries) GetIssues(ctx context.Context, arg GetIssuesParams) ([]GetIssuesRow, error) {
	rows, err := q.db.Query(ctx, getIssues, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIssuesRow
	for rows.Next() {
		var i GetIssuesRow
		if err := rows.Scan(
			&i.ID,
			&i.Scanid,
			&i.Matchedat,
			&i.Title,
			&i.Severity,
			&i.Createdat,
			&i.Updatedat,
			&i.Scansource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssuesByScanID = `-- name: GetIssuesByScanID :many
SELECT id, scanid, matchedat, title, severity, createdat, updatedat, scansource
FROM
	"public".issues WHERE scanid=$1
ORDER BY id
LIMIT $3 offset $2
`

type GetIssuesByScanIDParams struct {
	Scanid    int64
	SqlOffset int32
	SqlLimit  int32
}

type GetIssuesByScanIDRow struct {
	ID         int64
	Scanid     int64
	Matchedat  string
	Title      string
	Severity   string
	Createdat  time.Time
	Updatedat  time.Time
	Scansource string
}

func (q *Queries) GetIssuesByScanID(ctx context.Context, arg GetIssuesByScanIDParams) ([]GetIssuesByScanIDRow, error) {
	rows, err := q.db.Query(ctx, getIssuesByScanID, arg.Scanid, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIssuesByScanIDRow
	for rows.Next() {
		var i GetIssuesByScanIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Scanid,
			&i.Matchedat,
			&i.Title,
			&i.Severity,
			&i.Createdat,
			&i.Updatedat,
			&i.Scansource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssuesMatches = `-- name: GetIssuesMatches :many
SELECT id, matchedat, templatename, severity, author
FROM
	"public".issues WHERE scanid=$1
ORDER BY id
LIMIT $3 offset $2
`

type GetIssuesMatchesParams struct {
	Scanid    int64
	SqlOffset int32
	SqlLimit  int32
}

type GetIssuesMatchesRow struct {
	ID           int64
	Matchedat    string
	Templatename string
	Severity     string
	Author       sql.NullString
}

func (q *Queries) GetIssuesMatches(ctx context.Context, arg GetIssuesMatchesParams) ([]GetIssuesMatchesRow, error) {
	rows, err := q.db.Query(ctx, getIssuesMatches, arg.Scanid, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIssuesMatchesRow
	for rows.Next() {
		var i GetIssuesMatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.Matchedat,
			&i.Templatename,
			&i.Severity,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScan = `-- name: GetScan :one
SELECT name, status, scantime, hosts, scansource, templates, targets, config, runnow, reporting, scheduleoccurence, 
	scheduletime, id
FROM
	"public".scans WHERE id=$1 LIMIT 1
`

func (q *Queries) GetScan(ctx context.Context, id int64) (Scan, error) {
	row := q.db.QueryRow(ctx, getScan, id)
	var i Scan
	err := row.Scan(
		&i.Name,
		&i.Status,
		&i.Scantime,
		&i.Hosts,
		&i.Scansource,
		&i.Templates,
		&i.Targets,
		&i.Config,
		&i.Runnow,
		&i.Reporting,
		&i.Scheduleoccurence,
		&i.Scheduletime,
		&i.ID,
	)
	return i, err
}

const getScans = `-- name: GetScans :many
SELECT name, status, scantime, hosts, scansource, templates, targets, config, runnow, reporting, scheduleoccurence, 
	scheduletime, id
FROM
	"public".scans
ORDER BY id
LIMIT $2 offset $1
`

type GetScansParams struct {
	SqlOffset int32
	SqlLimit  int32
}

func (q *Queries) GetScans(ctx context.Context, arg GetScansParams) ([]Scan, error) {
	rows, err := q.db.Query(ctx, getScans, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scan
	for rows.Next() {
		var i Scan
		if err := rows.Scan(
			&i.Name,
			&i.Status,
			&i.Scantime,
			&i.Hosts,
			&i.Scansource,
			&i.Templates,
			&i.Targets,
			&i.Config,
			&i.Runnow,
			&i.Reporting,
			&i.Scheduleoccurence,
			&i.Scheduletime,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScansBySearchKey = `-- name: GetScansBySearchKey :many
SELECT name, status, scantime, hosts, scansource, templates, targets, config, runnow, reporting, scheduleoccurence, 
	scheduletime, id
FROM
	"public".scans WHERE name LIKE '%'||$1||'%'
`

func (q *Queries) GetScansBySearchKey(ctx context.Context, dollar_1 sql.NullString) ([]Scan, error) {
	rows, err := q.db.Query(ctx, getScansBySearchKey, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scan
	for rows.Next() {
		var i Scan
		if err := rows.Scan(
			&i.Name,
			&i.Status,
			&i.Scantime,
			&i.Hosts,
			&i.Scansource,
			&i.Templates,
			&i.Targets,
			&i.Config,
			&i.Runnow,
			&i.Reporting,
			&i.Scheduleoccurence,
			&i.Scheduletime,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScansForSchedule = `-- name: GetScansForSchedule :many
SELECT name, status, scantime, hosts, scansource, templates, targets, config, runnow, reporting, 
	scheduletime, id
FROM
	"public".scans WHERE scheduleoccurence=$1
`

type GetScansForScheduleRow struct {
	Name         string
	Status       string
	Scantime     int64
	Hosts        int64
	Scansource   string
	Templates    []string
	Targets      []string
	Config       sql.NullString
	Runnow       sql.NullBool
	Reporting    sql.NullString
	Scheduletime sql.NullString
	ID           int64
}

func (q *Queries) GetScansForSchedule(ctx context.Context, scheduleoccurence sql.NullString) ([]GetScansForScheduleRow, error) {
	rows, err := q.db.Query(ctx, getScansForSchedule, scheduleoccurence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScansForScheduleRow
	for rows.Next() {
		var i GetScansForScheduleRow
		if err := rows.Scan(
			&i.Name,
			&i.Status,
			&i.Scantime,
			&i.Hosts,
			&i.Scansource,
			&i.Templates,
			&i.Targets,
			&i.Config,
			&i.Runnow,
			&i.Reporting,
			&i.Scheduletime,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByName = `-- name: GetSettingByName :one
SELECT settingdata, datatype
FROM
	"public".settings WHERE name=$1 LIMIT 1
`

type GetSettingByNameRow struct {
	Settingdata string
	Datatype    string
}

func (q *Queries) GetSettingByName(ctx context.Context, name string) (GetSettingByNameRow, error) {
	row := q.db.QueryRow(ctx, getSettingByName, name)
	var i GetSettingByNameRow
	err := row.Scan(&i.Settingdata, &i.Datatype)
	return i, err
}

const getSettings = `-- name: GetSettings :many
SELECT settingdata, datatype, name
FROM
	"public".settings
`

func (q *Queries) GetSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.db.Query(ctx, getSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Settingdata, &i.Datatype, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTarget = `-- name: GetTarget :one
SELECT name, internalid, filename, total, createdat, updatedat
FROM
	public.targets WHERE ID=$1 LIMIT 1
`

type GetTargetRow struct {
	Name       string
	Internalid string
	Filename   string
	Total      int64
	Createdat  time.Time
	Updatedat  time.Time
}

func (q *Queries) GetTarget(ctx context.Context, id int64) (GetTargetRow, error) {
	row := q.db.QueryRow(ctx, getTarget, id)
	var i GetTargetRow
	err := row.Scan(
		&i.Name,
		&i.Internalid,
		&i.Filename,
		&i.Total,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getTargetByName = `-- name: GetTargetByName :one
SELECT id, internalid, filename, total, createdat, updatedat
FROM
	public.targets WHERE name=$1 LIMIT 1
`

type GetTargetByNameRow struct {
	ID         int64
	Internalid string
	Filename   string
	Total      int64
	Createdat  time.Time
	Updatedat  time.Time
}

func (q *Queries) GetTargetByName(ctx context.Context, name string) (GetTargetByNameRow, error) {
	row := q.db.QueryRow(ctx, getTargetByName, name)
	var i GetTargetByNameRow
	err := row.Scan(
		&i.ID,
		&i.Internalid,
		&i.Filename,
		&i.Total,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getTargets = `-- name: GetTargets :many
SELECT id, name, createdat, updatedat, internalid, filename, total
FROM
	public.targets
ORDER BY id
LIMIT $2 offset $1
`

type GetTargetsParams struct {
	SqlOffset int32
	SqlLimit  int32
}

type GetTargetsRow struct {
	ID         int64
	Name       string
	Createdat  time.Time
	Updatedat  time.Time
	Internalid string
	Filename   string
	Total      int64
}

func (q *Queries) GetTargets(ctx context.Context, arg GetTargetsParams) ([]GetTargetsRow, error) {
	rows, err := q.db.Query(ctx, getTargets, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTargetsRow
	for rows.Next() {
		var i GetTargetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Createdat,
			&i.Updatedat,
			&i.Internalid,
			&i.Filename,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTargetsForSearch = `-- name: GetTargetsForSearch :many
SELECT id, name, createdat, updatedat, internalid, filename, total
FROM
	"public".targets WHERE name LIKE '%'||$1||'%' OR filename LIKE '%'||$1||'%'
ORDER BY id
LIMIT $3 offset $2
`

type GetTargetsForSearchParams struct {
	Column1   sql.NullString
	SqlOffset int32
	SqlLimit  int32
}

type GetTargetsForSearchRow struct {
	ID         int64
	Name       string
	Createdat  time.Time
	Updatedat  time.Time
	Internalid string
	Filename   string
	Total      int64
}

func (q *Queries) GetTargetsForSearch(ctx context.Context, arg GetTargetsForSearchParams) ([]GetTargetsForSearchRow, error) {
	rows, err := q.db.Query(ctx, getTargetsForSearch, arg.Column1, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTargetsForSearchRow
	for rows.Next() {
		var i GetTargetsForSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Createdat,
			&i.Updatedat,
			&i.Internalid,
			&i.Filename,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplateContents = `-- name: GetTemplateContents :one
SELECT contents FROM public.templates WHERE path=$1 LIMIT 1
`

func (q *Queries) GetTemplateContents(ctx context.Context, path string) (string, error) {
	row := q.db.QueryRow(ctx, getTemplateContents, path)
	var contents string
	err := row.Scan(&contents)
	return contents, err
}

const getTemplates = `-- name: GetTemplates :many
SELECT id, name, folder, "path", createdat, updatedat, hash
FROM
	"public".templates
ORDER BY id desc 
LIMIT $2 offset $1
`

type GetTemplatesParams struct {
	SqlOffset int32
	SqlLimit  int32
}

type GetTemplatesRow struct {
	ID        int64
	Name      string
	Folder    string
	Path      string
	Createdat time.Time
	Updatedat time.Time
	Hash      string
}

func (q *Queries) GetTemplates(ctx context.Context, arg GetTemplatesParams) ([]GetTemplatesRow, error) {
	rows, err := q.db.Query(ctx, getTemplates, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTemplatesRow
	for rows.Next() {
		var i GetTemplatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Folder,
			&i.Path,
			&i.Createdat,
			&i.Updatedat,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplatesByFolder = `-- name: GetTemplatesByFolder :many
SELECT id, name, "path", createdat, updatedat, hash
FROM
	"public".templates WHERE folder=$1
`

type GetTemplatesByFolderRow struct {
	ID        int64
	Name      string
	Path      string
	Createdat time.Time
	Updatedat time.Time
	Hash      string
}

func (q *Queries) GetTemplatesByFolder(ctx context.Context, folder string) ([]GetTemplatesByFolderRow, error) {
	rows, err := q.db.Query(ctx, getTemplatesByFolder, folder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTemplatesByFolderRow
	for rows.Next() {
		var i GetTemplatesByFolderRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.Createdat,
			&i.Updatedat,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplatesByFolderOne = `-- name: GetTemplatesByFolderOne :one
SELECT id, name, "path", createdat, updatedat, hash
FROM
	"public".templates WHERE folder=$1 LIMIT 1
`

type GetTemplatesByFolderOneRow struct {
	ID        int64
	Name      string
	Path      string
	Createdat time.Time
	Updatedat time.Time
	Hash      string
}

func (q *Queries) GetTemplatesByFolderOne(ctx context.Context, folder string) (GetTemplatesByFolderOneRow, error) {
	row := q.db.QueryRow(ctx, getTemplatesByFolderOne, folder)
	var i GetTemplatesByFolderOneRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.Createdat,
		&i.Updatedat,
		&i.Hash,
	)
	return i, err
}

const getTemplatesBySearchKey = `-- name: GetTemplatesBySearchKey :many
SELECT id, name, folder, "path", createdat, updatedat, hash
FROM
	"public".templates WHERE path LIKE '%'||$1||'%'
ORDER BY id
LIMIT $3 offset $2
`

type GetTemplatesBySearchKeyParams struct {
	Column1   sql.NullString
	SqlOffset int32
	SqlLimit  int32
}

type GetTemplatesBySearchKeyRow struct {
	ID        int64
	Name      string
	Folder    string
	Path      string
	Createdat time.Time
	Updatedat time.Time
	Hash      string
}

func (q *Queries) GetTemplatesBySearchKey(ctx context.Context, arg GetTemplatesBySearchKeyParams) ([]GetTemplatesBySearchKeyRow, error) {
	rows, err := q.db.Query(ctx, getTemplatesBySearchKey, arg.Column1, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTemplatesBySearchKeyRow
	for rows.Next() {
		var i GetTemplatesBySearchKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Folder,
			&i.Path,
			&i.Createdat,
			&i.Updatedat,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplatesForScan = `-- name: GetTemplatesForScan :many
SELECT path, contents FROM public.templates WHERE id=$1
`

//这里查找有问题，还是应该给template加上templateID字段进行严格匹配，加上id = $1 or

type GetTemplatesForScanRow struct {
	Path     string
	Contents string
}

func (q *Queries) GetTemplatesForScan(ctx context.Context, id int) ([]GetTemplatesForScanRow, error) {
	rows, err := q.db.Query(ctx, getTemplatesForScan, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTemplatesForScanRow
	for rows.Next() {
		var i GetTemplatesForScanRow
		if err := rows.Scan(&i.Path, &i.Contents); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersion = `-- name: GetVersion :one
SELECT templates FROM "public".versions WHERE id=1 LIMIT 1
`

func (q *Queries) GetVersion(ctx context.Context) (string, error) {
	row := q.db.QueryRow(ctx, getVersion)
	var templates string
	err := row.Scan(&templates)
	return templates, err
}

const insertOrUpdateVersion = `-- name: InsertOrUpdateVersion :exec
INSERT INTO "public".versions 
(id, templates) VALUES
(1, $1) ON CONFLICT (id) DO UPDATE set templates=$1
`

func (q *Queries) InsertOrUpdateVersion(ctx context.Context, templates string) error {
	_, err := q.db.Exec(ctx, insertOrUpdateVersion, templates)
	return err
}

const setSettings = `-- name: SetSettings :exec
INSERT INTO "public".settings
	( settingdata, datatype, name) VALUES ( $1, $2, $3) ON CONFLICT (name) DO UPDATE SET settingdata=$1
`

type SetSettingsParams struct {
	Settingdata string
	Datatype    string
	Name        string
}

func (q *Queries) SetSettings(ctx context.Context, arg SetSettingsParams) error {
	_, err := q.db.Exec(ctx, setSettings, arg.Settingdata, arg.Datatype, arg.Name)
	return err
}

const updateIssue = `-- name: UpdateIssue :exec
UPDATE "public".issues SET issuestate=$2 WHERE id=$1
`

type UpdateIssueParams struct {
	ID         int64
	Issuestate string
}

func (q *Queries) UpdateIssue(ctx context.Context, arg UpdateIssueParams) error {
	_, err := q.db.Exec(ctx, updateIssue, arg.ID, arg.Issuestate)
	return err
}

const updateScanState = `-- name: UpdateScanState :exec
UPDATE "public".scans SET status=$2 WHERE id=$1
`

type UpdateScanStateParams struct {
	ID     int64
	Status string
}

func (q *Queries) UpdateScanState(ctx context.Context, arg UpdateScanStateParams) error {
	_, err := q.db.Exec(ctx, updateScanState, arg.ID, arg.Status)
	return err
}

const updateSettings = `-- name: UpdateSettings :exec
UPDATE "public".settings SET settingdata=$1 WHERE name=$2
`

type UpdateSettingsParams struct {
	Settingdata string
	Name        string
}

func (q *Queries) UpdateSettings(ctx context.Context, arg UpdateSettingsParams) error {
	_, err := q.db.Exec(ctx, updateSettings, arg.Settingdata, arg.Name)
	return err
}

const updateTargetMetadata = `-- name: UpdateTargetMetadata :exec
UPDATE targets SET total=total+$1 , updatedAt=NOW() WHERE id=$2
`

type UpdateTargetMetadataParams struct {
	Total int64
	ID    int64
}

func (q *Queries) UpdateTargetMetadata(ctx context.Context, arg UpdateTargetMetadataParams) error {
	_, err := q.db.Exec(ctx, updateTargetMetadata, arg.Total, arg.ID)
	return err
}

const updateTemplate = `-- name: UpdateTemplate :exec
UPDATE public.templates SET contents=$1, updatedat=$2, hash=$4 WHERE path=$3
`

type UpdateTemplateParams struct {
	Contents  string
	Updatedat time.Time
	Path      string
	Hash      string
}

func (q *Queries) UpdateTemplate(ctx context.Context, arg UpdateTemplateParams) error {
	_, err := q.db.Exec(ctx, updateTemplate,
		arg.Contents,
		arg.Updatedat,
		arg.Path,
		arg.Hash,
	)
	return err
}
